# Fixed Window vs Sliding Window 정리

## 1. 개요

레이트 리미팅(Rate Limiting)에서 가장 기본이 되는 두 가지 알고리즘은 **Fixed Window Counter**(고정 윈도우)와 **Sliding Window**(슬라이딩 윈도우)이다.

두 방식 모두 일정한 시간 창(window) 동안의 요청 수를 제한하지만, **시간 창을 고정하느냐** 또는 **현재 시각을 기준으로 이동시키느냐**에 따라 동작 방식이 달라진다.

---

## 2. 어원과 개념

| 용어 | 의미 | 비유 |
|------|-------|------|
| **Fixed Window** | 고정된 시간 단위(예: 1초, 1분)로 요청 수를 계산 | 초 단위 박스에 요청을 세고, 다음 초로 넘어가면 초기화 |
| **Sliding Window** | 현재 시각 기준으로 바로 이전 일정 구간의 요청 수 계산 | 창이 매 순간 부드럽게 이동하며 요청을 세는 방식 |

즉,
- **Fixed** → 시계처럼 ‘딱딱 끊어진 구간’ 기준
- **Sliding** → 매 순간 ‘연속적으로 이동하는 구간’ 기준

---

## 3. 원리 비교

### (1) Fixed Window Counter

> "1초에 최대 10건 허용" 예시

1초 동안 요청을 세다가 다음 초로 넘어가면 카운터를 초기화한다.

```text
시간(초):  | 0s | 1s | 2s | 3s |
요청 수  :  | 10 |  0 |  8 |  9 |
```

- 간단한 카운팅 로직 (Map<timestamp, count>) 으로 구현 가능
- 초가 바뀌면 카운터가 리셋됨

⚠️ **경계 버스트 문제**
- 0.9초~1.0초 구간에 10개, 1.0초~1.1초 구간에 10개가 들어오면 실제 0.2초 사이에 20건이 통과

👉 장점: 단순하고 빠름  
👉 단점: 경계 버스트 발생 가능

---

### (2) Sliding Window Log

> "최근 1초 동안 최대 10건 허용"

현재 요청이 들어올 때마다 **1초 이전 요청을 제거**하고, 남은 요청 수가 10 미만이면 통과한다.

```java
Deque<Long> deque = new ArrayDeque<>();
long now = System.currentTimeMillis();
deque.removeIf(t -> t < now - 1000); // 1초 이전 요청 제거
if (deque.size() < 10) {
    deque.addLast(now);
    allow();
} else {
    reject();
}
```

📊 결과: 어떤 1초 구간에서도 요청이 10건을 넘지 않는다. (정확한 제어)

👉 장점: 정확하고 공정함  
👉 단점: 매 요청마다 오래된 로그를 제거해야 하므로 성능 부담 있음

---

## 4. 수학적 비교

| 항목 | Fixed Window | Sliding Window |
|------|---------------|----------------|
| 시간 창 | 고정 | 현재 시각 기준으로 이동 |
| 정확도 | 낮음 (버스트 가능) | 높음 (정확한 제어) |
| 구현 난이도 | 쉬움 | 다소 복잡 |
| 성능 | 빠름 | 느림 (O(n)) |
| 최대 버스트 | 최대 2배 | 없음 |

---

## 5. 시각화 예시

### Fixed Window (1초 단위)

```
|------1s------|------1s------|
■■■■■■■■■■          ← 첫 구간 10회 (0.9초까지)
           ■■■■■■■■■■ ← 두 번째 구간 10회 (1.0초~)
→ 실제 0.9~1.1초 사이 총 20회 발생 가능 ❌
```

### Sliding Window (연속 1초 단위)

```
<---- 이동하는 1초 창 ---->
요청 시점이 1초를 벗어나면 deque에서 제거됨
→ 어떤 1초 구간에서도 최대 10회만 존재 ⭕
```

---

## 6. 구현 변형

| 알고리즘 | 설명 |
|-----------|------|
| **Sliding Log** | 요청 타임스탬프를 직접 저장 (`Deque<Long>`) |
| **Sliding Counter** | 이전 윈도우 비율로 보간하는 근사화 방식 (AWS API Gateway) |
| **Token Bucket / Leaky Bucket** | Sliding Window를 효율적으로 근사화한 버전, 시간 기반 토큰 누적 방식 |

> Token Bucket은 Sliding Window의 연속적 동작을 수학적으로 근사화하여, **정확도와 효율성을 모두 확보한 하이브리드 알고리즘**이다.

---

## 7. 실제 사용 예시

| 시스템 | 알고리즘 | 특징 |
|--------|------------|------|
| Nginx, Spring Cloud Gateway | Fixed Window 또는 Token Bucket | 단순하고 빠름 |
| AWS API Gateway | Sliding Counter | 정확도 향상, 계산 효율 높음 |
| Stripe, Cloudflare | Token Bucket | 정밀 제어와 고성능의 균형 |
| Redis Lua 기반 분산 제어 | Sliding Log | 분산 환경에서도 정확 제어 |

---

## ✅ 핵심 요약

| 항목 | Fixed Window | Sliding Window |
|------|---------------|----------------|
| 의미 | 고정된 시간 창 | 이동하는 시간 창 |
| 원리 | 초 단위 카운터 리셋 | 현재 시각 기준 1초 요청 계산 |
| 버스트 | 최대 2배 가능 | 없음 |
| 정확도 | 낮음 | 높음 |
| 성능 | 빠름 | 느림 |
| 대표 구현 | 초당 카운터 | Deque / Sliding Counter / Token Bucket |

---

### 📘 요약 문장
> Fixed Window는 단순하지만 경계 폭주가 발생할 수 있고,  
> Sliding Window는 정확하지만 연산 비용이 높다.  
> 실무에서는 이 둘의 중간 형태인 **Token Bucket**이 가장 널리 사용된다.

